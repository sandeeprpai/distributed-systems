/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "airport.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define pi 3.14159265358979323846

typedef struct kdnode kdtree;

struct kdnode
{
  char name[64];
  char code[3];
  double coords[3];
  kdtree *left;
  kdtree *right;
};

void NearestFive(kdtree *hd, kdtree list[], double coords[], int axis);
void quickSort(kdtree list[], int, int, int);
int partition(kdtree list[], int, int, int);
kdtree *head;

list_location_res *
listlocation_1_svc(location_as *argp, struct svc_req *rqstp)
{
	static list_location_res  result;
	xdr_free((xdrproc_t)xdr_list_location_res, (char *)&result);

	result.errno=0;
	airport_list_as* airList = &result.list_location_rest_u.list;
	
	kdtree list[5];
	double coords[2];
	coords[0] = argp->latitude;
	coords[1] = argp->longitude;
	int x = 0;
	for(x = 0; x<5; x++){
		list[x].coords[0]=0;
		list[x].coords[1]=0;
		list[x].coords[2]=10000;
		list[x].name[0]='a';
		list[x].code[0]='a';
	}
	//get closest 5 airports
	NearestFive(head, list, coords, 1);

	int i = 0;
	airport_list_as al;
	for(i = 0; i<5; i++){
		al = (airport_info_as *)malloc(sizeof(struct airport_info_as));
		al->distance = list[i].coords[2];
		al->name = strdup(list[i].name);
		al->code = strdup(list[i].code);
		al->next = NULL;
		*airList = al;
		airList = &al->next;
	}

	return &result;
}

//Create the tree given a list of kdnodes
//Returns head of the tree
struct kdtree *kd_create(kdtree list[], int left, int right, int axis)
{
	if(left>right){
		return NULL;
	}
	
	struct kdtree *tree;

	if(!(tree = malloc(sizeof *tree))) {
		return 0;
	}
	quickSort(list, left, right, axis);

	int median = left+((right-left)/2);
	strcpy(tree->name,list[median].name);
	strcpy(tree->code,list[median].code);
	tree->coords[0]= list[median].coords[0];
	tree->coords[1]= list[median].coords[1];	
	if(left<right){
		tree->left = kd_create(list, left, median-1, (axis+1)%2);
		tree->right = kd_create(list, median+1, right, (axis+1)%2);
	}
	
	return tree;
}

//Quicksort of the list
void quickSort(kdtree list[], int left, int right, int axis) {
	if( left < right ){
		int p = partition(list, left, right, axis);
		quickSort(list, left, p-1, axis);
		quickSort(list, p+1, right, axis);
  }
}

int partition(kdtree list[], int left, int right, int axis) {
  int i, j;
  kdtree t;
  double pivot = list[left].coords[axis];
  i = left; j = right+1;
  while(1){
	do ++i;
	while( list[i].coords[axis] <= pivot && i <= right );
	do --j;
	while( list[j].coords[axis] > pivot );
	if( i >= j )
	  break;
	t = list[i];
	list[i] = list[j];
	list[j] = t;
  }
  t = list[left];
  list[left] = list[j];
  list[j] = t;
  return j;
}

//Distance calculation between two coords
double deg2rad(double deg);
double rad2deg(double rad);

double distance(double lat1, double lon1, double lat2, double lon2, char unit){
  double theta, dist;
  theta = lon1 - lon2;
  dist = sin(deg2rad(lat1)) * sin(deg2rad(lat2)) + cos(deg2rad(lat1)) *
	cos(deg2rad(lat2)) * cos(deg2rad(theta));
  dist = acos(dist);
  dist = rad2deg(dist);
  dist = dist * 60 * 1.1515;
  switch(unit) {
  case 'M':
	break;
  case 'K':
	dist = dist * 1.609344;
	break;
  case 'N':
	dist = dist * 0.8684;
	break;
  }
  return (dist);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:: This function converts decimal degrees to radians :*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
double deg2rad(double deg) {
 return (deg * pi / 180);
}
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:: This function converts radians to decimal degrees :*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
double rad2deg(double rad) {
 return (rad * 180 / pi);
}

//Searching 5 closest nodes
void copyNode(kdtree *h, kdtree n[]){
  strcpy(n[4].name, h->name);
  strcpy(n[4].code, h->code);
  n[4].coords[0]=h->coords[0];
  n[4].coords[1]=h->coords[1];
  n[4].left=h->left;
  n[4].right=h->right;
}

void NearestFive(kdtree *hd, kdtree list[], double coords[], int axis) {
  if(hd!=NULL) {
	if(hd->coords[axis]>coords[axis]) {
	  NearestFive(hd->left, list, coords, (axis+1)%2);
	  if(list[4].coords[0] == 0 && list[4].coords[1] == 0) {
		copyNode(hd, list);
		list[4].coords[2]=distance(coords[0], coords[1],
								   hd->coords[0], hd->coords[1],'M');
		quickSort(list, 0, 4, 2);
	  } else if(distance(coords[0], coords[1],
						hd->coords[0], hd->coords[1],'M')<
			   distance(coords[0], coords[1],
						list[4].coords[0], list[4].coords[1],'M')) {
		copyNode(hd, list);
		list[4].coords[2] = distance(coords[0], coords[1],
								   hd->coords[0], hd->coords[1],'M');
		quickSort(list, 0, 4, 2);
	  }
	  double lat1 = coords[0];
	  double lon1 = coords[1];
	  double lat2 = hd->coords[0];
	  double lon2 = hd->coords[1];
	  if(axis == 1) {
		lat2 = lat1;
	  } else {
		lon2 = lon1;
	  }
	  if(list[4].coords[0] == 0 && list[4].coords[1] == 0||
		 distance(lat1, lon1, lat2, lon2,'M')<
		 distance(list[4].coords[0],list[4].coords[1],
				  coords[0],coords[1],'M'))
		NearestFive(hd->right, list, coords, (axis+1)%2);
	} else {
	  NearestFive(hd->right, list, coords, (axis+1)%2);
	  if(list[4].coords[0]==0&&list[4].coords[1]==0) {
		copyNode(hd, list);
		list[4].coords[2]=distance(coords[0], coords[1],
								   hd->coords[0], hd->coords[1],'M');
		quickSort(list, 0, 4, 2);
	  } else if(distance(coords[0], coords[1],
						hd->coords[0], hd->coords[1],'M')<
			   distance(coords[0], coords[1],
						list[4].coords[0], list[4].coords[1],'M')){
		copyNode(hd, list);
		list[4].coords[2]=distance(coords[0], coords[1],
								   hd->coords[0], hd->coords[1],'M');
		quickSort(list, 0, 4, 2);
	  }
	  double lat1=coords[0];
	  double lon1=coords[1];
	  double lat2=hd->coords[0];
	  double lon2=hd->coords[1];
	  if(axis==1){
		lat2=lat1;
	  }else{
		lon2=lon1;
	  }
	  if(list[4].coords[0]==0&&list[4].coords[1]==0||
		 distance(lat1,lon1,lat2,lon2,'M')<
		 distance(list[4].coords[0],list[4].coords[1],
				  coords[0],coords[1],'M'))
		NearestFive(hd->left, list, coords, (axis+1)%2);
	}
  }
}

void main2() {
	FILE *file = fopen("airport-locations.txt", "r");
	if(file == NULL) {
		printf("File not found.\n");
		return;
	}

	kdtree sample[1500];
	char str[255], *latitude, *longitude, *temp;
	int i = 0;

	while(fgets(str, 255, file)!=NULL) {
		if(str[0]=='[' && str[1]!='a') {
			sample[i].code[0]=str[1];
			sample[i].code[1]=str[2];
			sample[i].code[2]=str[3];
			lat=strchr(str, ' ');
			sample[i].coords[0]=strtod(lat+1,&lon);
			sample[i].coords[1]=strtod(lon,&cpy);
			strcpy(str, cpy);
			int x=0, y=0;
			while((str[x]=='\t' || str[x]==' ') && str[x]!='\0'){
				x++;
			}
			while(str[x]!='\n' && str[x]!='\0'){
				sample[i].name[y]=str[x];
				x++;
				y++;
			}
			i++;
		}
	}
	head = kd_create(sample, 0, i-1, 1);
}
